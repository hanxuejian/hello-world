# unrecognized selector sent to instance
在编写程序的过程中，即使编译通过，但是在运行的过程中，偶尔会有类似 **`unrecognized selector sent to instance`** 的错误。该错误的意思是不能识别的实例方法，造成该错误的原因可能是该实例的类中并没有定义要调用的方法，或者是在调用该方法前，这个实例所在的内存空间被释放而后分配给了其他类的实例变量。

除此之外，在使用第三方静态库时，也可能导致该问题，这是由 OC 的动态性与 UNIX 库的静态性造成的。对于 C 程序而言，当源代码经过编译器编译后，会生成许多个目标文件，目标文件中可能使用了其他目标文件中的类及方法，便会在目标文件中产生一个未定义的符号，而之后，链接程序会根据这些未定义符号找到相应的目标文件，将需要的类及方法链接到同一个文件中，这样最终得到一个可以执行的程序。为了减小执行程序的大小，链接程序只会链接目标文件中未定义的符号，可是在 Objective-C 语言中，其方法是在方法被调用时才会确定，所以编译程序只会确定一个目标文件中未定义的类符号，而不去生成未定义的方法符号，故而，编译程序也不会将需要的方法链接到目标文件中。

所以，在使用静态库中的分类方法时，因为其类已经定义过了，链接程序不会去进行链接，最终程序在运行的过程中，找不到分类中的方法，导致了该错误的发生。

为了避免该错误，需要到 **target -> Build Settings** 中修改 **Other Linker Flags** 的值，将其设置为 **-ObjC**，该值意在将静态库中所有的Objective-C 类和分类都加载到最后的可执行文件中。

另外，**Other Linker Flags** 还可以设置其他的值：

* **-all_load** 会将库中所有的的目标文件都加入到可执行文件中，这样做会导致一个问题，如果引用了两个静态库，而这两个静态库恰好都引用了同一个第三发库，那么会报重复定义的错误 **duplicate symbol**。
* **-force_load** 该值与 -all_load 相同，只是其后面需要指定具体要全部加载的库的路径，而其他库仍按需加载。

