Objective-C 运行时学习
===
### 简介
Objective-C 语言会尽可能的将事情从编译及链接推迟到运行时才决定，其总是动态的决定事物。这意味着该语言不仅仅需要编译器也需要运行时系统来执行编译的代码，其对于 Objective-C 就如一种操作系统。

虽然不了解运行时系统，并不影响我们编写应用程序，但是学习该知识，我们可以知道 Objective-C 程序是如何与运行时系统进行交互的，并且在程序运行时，定义增加新类，发送消息给其他类对象，或获取类对象的信息。

### 运行时版本
运行时在不同的平台上有不同的版本，现在分为新旧两个版本，新版本是在 Objective-C 2.0 引入的，其相较于旧版本的运行时系统增加了一些新的特性，其中值得注意的是，在旧版本中，改变类中的实例变量后，需要重新编译继承该类的子类，而新版本的运行时系统则不需要重新编译，并且，新版本的运行时可以根据声明的类属性合成实例变量。

`iPhone 应用和 OS X v10.5 及其之后的64位平台上的应用程序均使用新版本的运行时，其他32位的平台使用的是旧版本的运行时。`

### 运行时交互
Objective-C 程序与运行时系统交互，通常通过三种方法：Objective-C 源码，NSObject 中定义的方法，运行时方法。

1. Objective-C 源码

	当我们在编写源码时，运行时系统自动运行，编译源码时，其从源码中提取实例变量，方法等信息生成数据结构及动态方法。其中最主要的动态方法是消息发送，该方法是源码中消息发送代码所产生。

2. NSObject 方法

	作为 Cocoa 中几乎所有类的父类 NSObject ，其所定义的方法被其他类继承，这些被继承的方法实现了一些必要的操作，被所有子类继承，但是也有些方法，并未进行任何操作，只是为了提供给子类重写。还有一些方法只是简单的向运行时系统查询信息，如 `isKindOfClass:` `isMemberOfClass:` `conformsToProtocol:`等方法，而这些方法与运行时的交互，为类对象检查自身信息提供了途径。

3. 运行时方法
	
	直接使用 `SDK` 中路径 `/usr/include/objc` 下的的数据结构及方法，使用纯 C 语言同运行时系统交互，可以进行与编译器编译 Objective-C 源码时一样的操作，并且可以开发更多开发工具，并且一些方法也是 Objective-C 中常用的。

### 运行时方法 objc_msgSend
在 Objective-C 中，消息表达式 `[receiver message]` 直到运行时，massage 才会绑定到实现方法上，该方法会转化为一个消息函数 `objc_msgSend(receiver,selector)` 这两个参数分别是消息接收对象 receiver 与 方法 message 相应的方法选择器 selector。当然，如果有参数，可以使用函数 `objc_msgSend(receiver, selector, arg1, arg2, ...)` ,该函数会找到并调用实现方法，而后将方法返回的值作为自己的返回值返回。

消息传递的关键在于编译器为每一个类和对象生成的结构，其包含两个基本要素：

* 指向父类的指针
* 消息分发表，这个表保存着方法选择器以及该选择器表示的方法的实现地址

当一个类对象创建时，分配内存并初始化变量，其第一个变量就是指向该对象的类的结构，变量名为 `isa` ,通过该变量，该对象就可以访问其所对应的类，及其继承的父类。如下图所示：

![](https://github.com/hanxuejian/hello-world/raw/master/pictures/2017/pic-20170413-01.png)

当消息发送给类对象后，objc_msgSend 根据对象的 isa 指针找到类结构，并搜索消息转发表中的 selector 方法选择器，若未找到，则继续搜索父类的转发表，直到根类 NSObject ，一旦找到相匹配的 selector ，则 objc_msgSend 将调用 selector 在表中所对应的方法，并将对象的数据结构传给该方法。

这个找寻消息的实现方法的过程是在运行时进行的，或者用面向对象编程的术语说，就是方法与消息的动态绑定。

为了提升消息发送过程的速度，运行系统会分别缓存每个类的 selector 与 方法地址的值，且包含该类继承的方法，当方法第一调用，其会加入该缓存，而消息转发时，也会先查找该缓存，时间足够长时，基本所有的消息转发均可在缓存中找到相应的实现方法，并且这个缓存会自动增加以适应不断加入的缓存数据。

当 objc_msgSend 函数找到相应方法的实现时，除了将消息中的参数传递给该方法外，还传递了另外两个隐式参数

* 接收消息的对象 receiver
* 方法的选择器 selector

之所以称其为隐式参数，是因为这两个参数并不在源代码的方法声明的参数列表中，而是编译器在编译时自己插入的，但在方法的实现代码中，还是可以用关键字 `self` 与 `_cmd` 获取对象本身及方法选择器的。

另外，若是能够获取方法的实现地址，便可以绕过消息与方法的动态绑定，可以使用 `NSObject` 中的方法 `methodForSelector` 获取 selector 所对应的方法实现地址。如下例程：

```
void (*setter)(id, SEL, BOOL);
int i;
 
setter = (void (*)(id, SEL, BOOL))[target methodForSelector:@selector(setFilled:)];
for ( i = 0 ; i < 1000 ; i++ ) {
    setter(targetList[i], @selector(setFilled:), YES);
}

```

这里需要注意的是，使用 `methodForSelector` 获取的方法需要进行类型转换，返回类型及参数均需要转换。转换时，前两个餐食是必须的也是固定的，分别为：消息接收者与方法选择器，而其后的参数的个数是任意的，这取决于你所要调用的方法，其返回类型也是一样。

这种绕过消息传送机制的做法比直接使用消息传送要节约时间，但也仅仅在一个方法不断反复调用时才有意义，如上面的例程那样，并且方法 `methodForSelector` 是运行时系统所提供的特性，而不是 Objective-C 语言本身的特性。

